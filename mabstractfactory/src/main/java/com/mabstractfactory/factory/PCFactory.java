package com.mabstractfactory.factory;

import com.mabstractfactory.product.Keyboard;
import com.mabstractfactory.product.Mouse;

/**
 * 设计模式：    抽象工厂模式
 *
 * 定义：        抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指
 *               当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客
 *               户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任
 *               何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这
 *               些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品
 *               的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例.<为创建一组相关或相互依赖
 *               的对象提供一个接口，而且无需指定他们的具体类。为创建一组相关或相互依赖的对象提供一
 *               个接口，而且无需指定他们的具体类./>
 *
 * 应用场景： 1. 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。
 *            2. 这个系统有多于一个的产品族，而系统只消费其中某一产品族。
 *            3. 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。
 *            4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。
 *
 * 优点：     1. 具有工厂方法模式解耦的优点。
 *            2. 工厂模式针对的是一个产品等级结构，抽象工厂模式针对的是面向多个产品等级结构的.
 *               最主要的是可以在类内部对产品族的关联关系进行定义和描述
 *
 * 缺点：     1. 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的
 *               工厂类都需要进行修改。
 *            2. 在具体工厂类的方法中，对于产品族里的产品，只能使用其中一个。这也比较容易理解，比如，
 *               一款车子不可以搭载两种空调。
 *
 */
public abstract class PCFactory {

    public abstract Mouse createMouse();

    public abstract Keyboard createKeyboard();

}
